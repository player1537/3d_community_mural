==================
3D Community Mural
==================

This project includes the server side component to the 3D Community
Mural project. The 3D aspects come from the use of OSPRay on the
server side, following a Tapestry-like architecture.


How to Run
----------

Before you run these commands, you need to have OSPRay downloaded. You
can download it from its Releases page on GitHub [0]. We are using
version 1.8.5.

To run the server, we need to create a Docker image with OSPRay
installed. You can do this by first running:

  $ ./go.sh build

Then to actually run the server:

  $ ./go.sh run python3.7 -u server.py /opt/app/server

Then open http://localhost:8801 and you will see the scene
rendered. You can click and drag on the image that's returned to
rotate around the scene. Zooming does not currently work well.

[0]: https://github.com/ospray/ospray/releases


Using the Service
-----------------

This service is best described as a web-accessible rendering service
that can be used entirely from requesting special URLs and getting
images (JPEGs) back. This means that after constructing a URL you
can use it in an HTML image tag.

The Seelab team will handle running the service until the MVP is
finished, after which point, we will hand off a Docker image that
can be run on production systems. The Seelab base URL is:

  http://accona.eecs.utk.edu:8801/

The service is entirely stateless, so it will not remember anything
between requests. This means that everything it needs to know to
render the scene will have to be passed every request. This means we
will need to know the camera position, camera view direction, camera
up direction, desired resolution, and any scene information. For
the community mural, most of these parameters can be fixed, which
simplifies the requests.

Here is a pair of JavaScript functions. The first one requires all
information in the Tapestry URLs. The second one has a simplified
interface that only needs the camera horizontal/vertical positions,
image resolution, and ball position.

function makeTapestryURL(options) {
	const O = options;
	
	const parts = [
		O.prefix,  // base URL
		'image',
		O.scene,
		O.px, O.py, O.pz,  // position
		O.ux, O.uy, O.uz,  // up
		O.vx, O.vy, O.vz,  // view
		O.quality,  // resolution (square image)
		O.extra,  // extra parameters, like tiling
	];
	
	return parts.join('/');
}

function makeMuralObject(options) {
	const O = options;
	
	const parts = [
		'obj' + O.number,  // e.g. "obj1"
		O.object,  // what object/model to use
		O.bx, O.by, O.bz,  // object position
		O.bsx, O.bsy, O.bsz,  // object scale
		O.material,  // ball material
	];
	
	return parts.join(',');
};

function makeMuralWall(options) {
	const O = options;
	
	const parts = [
		O.name,
		O.r, O.g, O.b,
	];
	
	return parts.join(',');
};

function makeMuralURL(options) {
	const O = options;
	
	const sceneParts = [
		'scene',
		makeMuralObject(O.obj1),
		makeMuralObject(O.obj2),
		makeMuralObject(O.obj3),
		makeMuralWall(O.negx),
		makeMuralWall(O.posx),
		makeMuralWall(O.negy),
		makeMuralWall(O.posy),
		makeMuralWall(O.negz),
		makeMuralWall(O.posz),
	];
	
	return makeTapestryURL({
		prefix: 'http://accona.eecs.utk.edu:8801',
		scene: sceneParts.join(','),
		px: O.cameraHorizontal,  // camera x
		py: O.cameraVertical,  // camera y
		pz: -2.0,  // camera depth
		ux: 0, uy: 1, uz: 0,
		vx: 0, vy: 0, vz: 1,
		quality: O.quality,
		extra: '',
	});
}

For example, you could use this to construct a render looking directly
at a ball, that is directly in the center of the scene.

const url = makeMuralURL({
	cameraHorizontal: 0.0,
	cameraVertical: 0.0,
	quality: 512,
	obj1: {
		number: 1,
		object: 'Donut',
		bx: 0.0, by: 0.0, bz: 0.5,
		bsx: 1.0, bsy: 2.0, bsz: 1.0,
		material: 'Emerald',
	},
	obj2: {
		number: 2,
		object: 'Platonic',
		bx: 0.5, by: 0.0, bz: 0.5,
		bsx: 1.0, bsy: 2.0, bsz: 1.0,
		material: 'Emerald',
	},
	obj3: {
		number: 3,
		object: 'Donut',
		bx: 0.0, by: 0.5, bz: 0.5,
		bsx: 1.0, bsy: 2.0, bsz: 1.0,
		material: 'Brass',
	},
	negx: {
		name: 'negx',
		r: 0.8, g: 0.2, b: 0.2,
	},
	posx: {
		name: 'posx',
		r: 0.2, g: 0.8, b: 0.2,
	},
	negy: {
		name: 'negy',
		r: 0.2, g: 0.8, b: 0.8,
	},
	posy: {
		name: 'posy',
		r: 0.8, g: 0.8, b: 0.8,
	},
	negz: {
		name: 'negz',
		r: 0.8, g: 0.2, b: 0.8,
	},
	posz: {
		name: 'posz',
		r: 0.2, g: 0.2, b: 0.8,
	},
});

This results in:

  http://accona.eecs.utk.edu:8801/image/scene,obj1,Donut,0,0,0.5,1,2,1,Emerald,obj2,Platonic,0.5,0,0.5,1,2,1,Emerald,obj3,Donut,0,0.5,0.5,1,2,1,Brass,negx,0.8,0.2,0.2,posx,0.2,0.8,0.2,negy,0.2,0.8,0.8,posy,0.8,0.8,0.8,negz,0.8,0.2,0.8,posz,0.2,0.2,0.8/0/0/-2/0/1/0/0/0/1/512/

The scene has a fixed size and has limits on X, Y, and Z. Anything
(camera or ball) can be put anywhere in this fixed space, but going
outside of it (e.g. X=3.5) will not work as expected.

  X: -1 (left) to +1 (right)
  Y: -1 (bottom) to +1 (top)
  Z: 0 (camera plane) to +1 (far end of the box)


Creating OBJ Models
-------------------

OSPRay natively supports triangle meshes. However, parsing OBJ files in
C isn't the most straightforward thing, and it adds to the processing
time. Instead, it is easier to make use of a preprocessing step to
convert the OBJ file into a raw binary file.

The mechanism to do this is in the obj_to_bin.py script, which uses
PyWavefront to parse the OBJ and MTL files.

The binary format is unique but simple:

  <header> := <u8 has_vertex> <u8 has_index> <u8 has_extra1> <u8 has_extra2>
  <vertex> := <i32 nvertex> { <f32 x> <f32 y> <f32 z> } ... (nvertex times)
  <index> := <i32 nindex> { <i32 i> <i32 j> <i32 k> } ... (nindex times)
  <extra1> := (unused)
  <extra2> := (unused)
  <data> := <header> \
            ( <vertex> if has_vertex ) \
            ( <index> if has_index ) \
            ( <extra1> if has_extra1 ) \
            ( <extra2> if has_extra2 )

has_vertex is either 'V' or '<spc>'. has_index is either 'I' or
'<spc>'. has_extra1 and has_extra2 aren't defined yet, so they are
currently both '<spc>'.

A Makefile exists to help convert the models more easily. To run it,
make sure all the models (and their MTL files) are in the models/
directory, then just run make to convert them all.

  $ tree models/
  models/
  ├── Donut2.mtl
  ├── Donut2.obj
  ├── Platonic2.mtl
  └── Platonic2.obj
  
  0 directories, 4 files
  $ make
  ./go.sh python obj_to_bin.py --output gen/Platonic2.bin models/Platonic2.obj
  ./go.sh python obj_to_bin.py --output gen/Donut2.bin models/Donut2.obj --rescale
  $ tree gen
  gen
  ├── Donut2.bin
  └── Platonic2.bin
  
  0 directories, 2 files

Inside the Makefile, you can specify if you want the model
rescaled. This will make it fit within a -1 to 1 sized box (keeping
aspect ratio). To enable it for a model (like Donut2), you would add
a line to the Makefile like:

  gen/Donut2.bin: rescale := --rescale

And the next time you build Donut2.bin, it will be rescaled correctly.


Materials
---------

There is a set of preloaded materials available to the user of the
service. These are based on a list available at:

  http://web.eecs.utk.edu/~huangj/cs456/materials_ogl.htm

They are referenced by name, with internal spaces removed. The current
master list of names is:

  Brass          Copper         Pewter         Jade           Turquoise
  Bronze         PolishedCopper Silver         Obsidian       BlackPlastic
  PolishedBronze Gold           PolishedSilver Pearl          BlackRubber
  Chrome         PolishedGold   Emerald        Ruby

Internally, these materials are loaded into the OSPRay process via
environment variables. On variable tells the number of materials to
load, and then the remaining variables follow a specific naming scheme.

  nmat: Number of materials to load (e.g. 12).
  mat_0: First material.
  mat_1: Second material.
  ...
  mat_11: Last material.

Each of the mat_ variables is a whitespace-delimited set of floats
(prefixed with a name). For example, Brass' environment variable
value is:

  Brass   0.329412 0.223529 0.027451 1.0  0.780392 0.568627 0.113725 1.0  0.992157 0.941176 0.807843 1.0  27.8974

These fields are, in order:

  Name, Diffuse R, G, B, Opacity, Specular R, G, B, Shininess

The server loads these from a materials.txt in the root of this
project. To create your own, add a line like the Brass one above to
the end of materials.txt. For instance, an opaque red matte material
might look like:

  Red  0.8 0 0  1  0.4 0 0  10

Then when you reload the server, you can refer to it by the name "Red".


Models
------

There is a list of preloaded OBJ models. They are referenced by name
with internal spaces removed. The current list of models is:

  Donut     Platonic

They are passed to OSPRay in almost exactly the same way as
materials. Like materials, there's a variable to say how many models
to load, and a variable for each model that specifies the path to
load from.

  nobj: Number of objects to load (e.g. 12).
  obj_0: First object.
  obj_1: Second object.
  ...
  obj_11: Last object.

Each of the obj_ variables is a pair of name and path, separated by
spaces. For example, Donut's value is:

  Donut gen/Donut2.bin

These fields are:

  Name, Path

These environment variables are loaded from an objs.txt file in the
root of the project. You can add your own model by appending lines
to objs.txt. For example:

  Platonic  gen/Platonic2.bin


Walls
-----

You can change the color of each wall to any RGB color. Each wall
is labeled as {Neg,Pos}{X,Y,Z}. In the scene URL, you would give a
particular wall name and then 3 floats. The exact wall names are:

  negx negy negz posx posy posz

An example specification for making the negx wall red is:

  negx,0.8,0.2,0.2


Miscellaneous Notes
-------------------

In the OSPRay code, it would be nice to be able create an instance with a different material than the instanced geometry. However, based on Instance.ispc in the OSPRay library, it only uses the instanced geometry's material.

  https://github.com/ospray/ospray/blob/43a89186b4dc8a17dc130e3295ad96ddf69cb029/ospray/geometry/Instance.ispc#L41-L43

OSPRay never explicitly defines what an affine3f is. You can find a struct definition in the ospray.h header file, but all you get is:

  typedef struct { osp_vec3f vx, vy, vz; }                    osp_linear3f;
  typedef struct { osp_linear3f l; osp_vec3f p; }             osp_affine3f;

To get the real definition, you have to look at Instance.h:

  Once created, a trianglemesh recognizes the following parameters
  <pre>
  float3 "xfm.l.vx" // 1st column of the affine transformation matrix
  float3 "xfm.l.vy" // 1st column of the affine transformation matrix
  float3 "xfm.l.vz" // 1st column of the affine transformation matrix
  float3 "xfm.p"    // 4th column (translation) of the affine transformation matrix
  OSPModel "model"  // model we're instancing

(Side note: I think "trianglemesh" above should be "instance").

A question I had is: why not just store the whole matrix? For affine transformations, you generally don't (never?) change the last row and leave it as 0, 0, 0, 1. In other words, for most use cases, your matrix will look like:

       l.vx    l.vy    l.vz      p
  [ [ XSCALE,      0,      0, XTRANS ]
    [      0, YSCALE,      0, YTRANS ]
    [      0,      0, ZSCALE, ZTRANS ]
    [      0,      0,      0,      1 ] ]

